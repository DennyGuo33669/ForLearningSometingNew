# 7.3 模仿块级作用域

前面说过,JavaScript没有块级作用域的概念.**这意味着在块语句中定义的变量,实际上是在包含函数中而非语句中创建的**

``` js line-numbers
function outputNumbers (count) {
  for (var i = 0; i < count; i++) {
    console.log(i);
  }
  console.log(i); // 计数
}
```

这个函数中定义了一个`for`循环,而变量`i`的初始值设置为0.在JAVA,C++等语言中,变量`i`只会在`for`循环的语句块中有定义,循环一旦结束,变量`i`就会被销毁.可是在JavaScript中,变量`i`是定义在`outputNumbers()`的活动对象中的,因此从它有定义开始,就可以在函数内部随机访问它.即使像下面这样错误地重新声明同一个变量,也不会改变它的值.

``` js line-numbers
function outputNumbers () {
  for (var i = 0; i < count; i++) {
    console.log(i);
  }

  var i;// 重新声明变量
  console.log(i); // 计数
}
```

JavaScript从来不会告诉你是否多次声明了同一个变量;遇到这种情况,它只会对后续的声明视而不见(不过,它会执行后续生命中的变量初始化).匿名函数可疑用来模仿块级作用域并避免这个问题.

用块作用域(通常称作**私有作用域**)的匿名函数的语法如下所示:

``` js line-numbers
(function () {
  // 这里是块级作用域
})();
```

以上代码定义并立即调用了一个匿名函数.将函数声明包含在一堆圆括号中,表示它实际上是一个函数表达式,而紧随其后的另一对圆括号会立即调用这个函数

无论什么地方,只要临时需要一些变量,就可以使用私有作用域:

``` js line-numbers
function outputNumbers (count) {
  (function () {
    for (var i = 0; i < count; i++) {
      console.log(i);
    }
  })();
  console.log(i); // 导致一个错误
}
```

在这个重写后的`outputNumbers()`函数中,我们在`for`循环外部插入了一个私有作用域.在匿名函数中定义的任何变量,都会在执行结束时被销毁.因此,变量`i`只能在循环中使用,使用后即被销毁.而在私有作用域中能够访问变量`count`,是因为这个匿名函数是一个闭包,它能够访问包含作用域中的所有变量.

这种技术经常在全局作用域被用在函数外部,从而限制向全局作用域中添加过多的变量和函数.一般来说,我们都应该尽量减少全局作用域中添加变量和函数.在一个由很多开发人员共同参与的大型应用程序中,过多的全局变量和函数很容易导致命名冲突.而通过穿件私有作用域,每个开发人员既可以使用自己的变量,又不必担心乱搞全局作用域:

``` js line-numbers
(function () {
  var now = new Date();
  if (now.getMonth() == 0 && now.getDate() == 1) {
    console.log('Happy new year!');
  }
})();
```

把上面这段代码放在全局作用域中,可以用来确定哪一天是1月1日;如果到了这一天.就会向童虎显示一条祝贺新年的消息.其中的变量`now`现在是匿名函数中的局部变量,而我们不必再全局作用中创建它.

*这种做法可疑减少闭包占用的内存问题,因为没有指向匿名函数的引用.只要函数执行完毕,就可以立即销毁其作用域链了*.
