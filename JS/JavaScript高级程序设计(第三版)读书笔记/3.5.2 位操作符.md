# 3.5.2 位操作符

位操作符用于**最基本**的层次上,按内存中表示数值的**位**来操作数值.ECMAScript中所有数值都以**IEEE-754 64位**格式存储,但位操作符并不直接操作64位的值,而是先将64位的值转换成32位的整数,然后执行操作,最后再将结果转回64位.对于开发人员来说,由于64位存储格式是透明的,因此整个过程就像只存在32位的整数一样.

对于有符号的整数,32位中前31位用于表示整数的值,最后一位表示符号,0为正,1为负.
其中正数以纯二进制格式存储,31位中的**每一位都是2的幂**.
例如 数值18的**二进制**表示就是**00000000000000000000000010010**,或者**10010**,

|   1    |   0    |   0    |   1    |   0    |
| :----: | :----: | :----: | :----: | :----: |
| 2^4^*1 | 2^3^*0 | 2^2^*0 | 2^1^*1 | 2^0^*0 |
|   16   |   0    |   0    |   2    |   0    |

负数同样以二进制存储,但使用的格式是**二进制补码**,计算一个补码,需要经过一下3个步骤

1.求这个数值**绝对值**的二进制码
2.求二进制**反码**,全部取反,0变1,1变0;
3.得到的二进制反码**加1**

求-18的二进制码:

0000 0000 0000 0000 0000 0000 0001 0010

**||**      求反码
**V**

1111 1111 1111 1111 1111 1111 1110 1101

**||**   +1
**V**

1111 1111 1111 1111 1111 1111 1110 1110

这样就得到了-18的二进制表示.要注意的是,在处理有符号整数时,是**不能**访问31位的.

ECMAScript会尽力向我们隐藏所有这些信息.(在以二进制输出一个负数时,我们看到的知识这个负数的绝对值的二进制码前面加了一个**负号**)

```js .line-numbers
var num = -18;
console.log(num.toString(2)); // "-10010"
```

ECMAScript中,对数值应用位操作符时,*先将64位的值转换成32位的整数,然后执行位操作,最后再将结果转回64位*.这样,表面上看起来就好像是在操作32位数值,就跟在其他语言中以类似方式执行二进制操作一样.但这个转换过程也导致了一个严重的副效应,即在对特殊的`NaN` 和 `Infinity`值应用位操作时,这两个值都会被当成**0**来处理.

如果对**非数值**应用位操作符,会先使用`Number()` 函数将该值转换为一个数值(自动完成),然后再应用位操作.得到的结果将是一个数值.

## 1.按位非(NOT)

按位非操作符由一个 **波浪线(~)** 表示,执行按位非的结果就是返回数值的**反码**.
按位非是ECMAScript操作符中少数几个与二进制计算有关的操作符之一.

```js .line-numbers
var num1 = 25; // 00000000000000000000000000011001
var num2 = ~num1; // 11111111111111111111111111100110
console.log(num2.toString(2)); // -26
```

这里对25执行按位非操作,结果得到-26.这也验证了按位非操作的本质:操作数的**负值减1**

```js .line-numbers
var num1 = 25;
var num2 = -num1 - 1;
console.log(num2); // "-26"
```

虽然以上代码也能返回同样的效果,但是由于**按位非**是在数字表示的最底层执行,因此速度更快.

## 2.按位与(AND)

按位与操作符由一个**和号字符(&)** 表示,它有两个操作数.本质上讲,按位与操作就是将两个数值的每一位对齐,然后根据下表中的规则,对相同位置上的两个数执行AND操作

| 第一个数位 | 第二个数位 | 结果 |
| ---------- | ---------- | ---- |
| 1          | 1          | 1    |
| 1          | 0          | 0    |
| 0          | 1          | 0    |
| 0          | 0          | 0    |

```js .line-numbers
var result = 25 & 3;
console.log(result); // 1
```

底层操作如下:

```js .line-numbers
25  = 0000 0000 0000 0000 0000 0000 0001 1001
 3  = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```

## 3.按位或(OR)

按位或操作符由一个**竖线符号(|)** 表示,同样也有两个操作数.

| 第一个数位 | 第二个数位 | 结果 |
| ---------- | ---------- | ---- |
| 1          | 1          | 1    |
| 1          | 0          | 1    |
| 0          | 1          | 1    |
| 0          | 0          | 0    |

```js .line-numbers
var result = 25 | 3;
console.log(result); // 27
```

底层操作如下:

```js .line-numbers
25  = 0000 0000 0000 0000 0000 0000 0001 1001
 3  = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
OR  = 0000 0000 0000 0000 0000 0000 0001 1011
```

## 4.按位异或(XOR)

按位异或操作符由一个**插入符号(^)** 表示,也有两个操作数.

| 第一个数位 | 第二个数位 | 结果 |
| ---------- | ---------- | ---- |
| 1          | 1          | 0    |
| 1          | 0          | 1    |
| 0          | 1          | 1    |
| 0          | 0          | 0    |

**按位异或** 和 按位或的不同之处在于,这个操作在两个数值对应为上只有一个1时才返回1,如果对应的两位都是1或都是0,则返回0.

```js .line-numbers
var result = 25 ^ 3;
console.log(result); // 26
```

底层操作如下:

```js .line-numbers
25  = 0000 0000 0000 0000 0000 0000 0001 1001
 3  = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0000 1010
```

## 5.左移

左移符号由**两个小于号(<<)** 表示,这个操作符会将数值的所有位向左移动指定的位数.
例如,将数值2(*二进制码为10*)向左移动5位,结果就是64(二进制码为1000000)

```js .line-numbers
var oldValue = 2; // 等于二进制的10
var newValue = oldValue << 5; // 等于二进制的1000000,十进制的64
```

```js .line-numbers
25  = 0000 0000 0000 0000 0000 0000 0001 1001
 3  = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0000 1010
```
